// mint 2
// Constants for ports and status flags
#10 DATA_PORT !
#11 COMMAND_PORT !
#12 STATUS_PORT !
#80 BUSY !
#1E ERROR_MASK !
#6C SADD !

// Variables
:RESULT 0 0 ;  // 16-bit result storage (high and low)
:ERROR 0 ;     // 8-bit error storage

// Initialize arguments
:INIT
  1 a !  // Set arg1 to 1
  1 b !  // Set arg2 to 1
;

// Store arguments in FPU
:STORE
  a DATA_PORT /O      // Push arg1 lower byte
  a } DATA_PORT /O    // Push arg1 higher byte (shift right for high byte)
  b DATA_PORT /O      // Push arg2 lower byte
  b } DATA_PORT /O    // Push arg2 higher byte (shift right for high byte)
;

// Send add command to FPU
:ADD
  SADD COMMAND_PORT /O
;

// Wait until FPU is not busy
:WAIT
  /U ( STATUS_PORT /I BUSY & /W )  // Loop until BUSY bit is clear
;

// Store any error code
:ERROR
  STATUS_PORT /I ERROR_MASK & { ERROR !  // Mask status, shift left, store
;

// Pop result from FPU and store it
:POP
  DATA_PORT /I l !      // Get lower byte
  DATA_PORT /I h !      // Get higher byte
  h 8 { l + RESULT !    // Combine bytes (shift left high byte) and store in RESULT
;

// Main program
:START
  INIT STORE ADD WAIT ERROR POP  // Execute main logic
  /U ( /K )  // Infinite wait for key input
;

// Run the program
START



///////////////////////////

#10 d!
#11 c !
#12 s !
#80 b!
#1E e !
#6C a!

// Variables
:R 0 0 ;  
// 16-bit R storage (high and low)
:E 0 ;     
// 8-bit Estorage

// Iialize arguments
:I
  1 a !  
// Set arg1 to 1
  1 b !  
// Set arg2 to 1
;

// S arguments in FPU
:S
  a d/O      
// Push arg1 lower byte
  a } d/O    
// Push arg1 higher byte (shift right for high byte)
  b d/O      
// Push arg2 lower byte
  b } d/O    
// Push arg2 higher byte (shift right for high byte)
;

// Send A command to FPU
:A
  ac /O
;

// W until FPU is not busy
:W
  /U ( s /I b& /W )  
// Loop until bbit is clear
;

// S any Ecode
:O
  s /I e & { E!  
// Mask status, shift left, S
;

// P R from FPU and S it
:P
  d/I l !      
// Get lower byte
  d/I h !      
// Get higher byte
  h 8 { l + R !    
// Combine bytes (shift left high byte) and S in R
;

// Main program
:T
  I S A W EP  
// Execute main logic
  /U ( /K )  
// InfIe W for key input
;

// Run the program
T


/////////////////////////////

